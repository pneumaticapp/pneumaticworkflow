# Generated by Django 2.2.16 on 2020-10-13 13:38

from django.db import migrations


def update_search_content(apps, schema_editor):
    pass


class Migration(migrations.Migration):

    dependencies = [
        ('processes', '0079_auto_20201007_0736'),
    ]

    operations = [
        migrations.RunSQL(
            sql='''
            DROP TRIGGER IF EXISTS process_ins ON processes_process;
            ''',
            reverse_sql='''
            CREATE TRIGGER process_ins BEFORE INSERT OR UPDATE ON processes_process FOR EACH ROW EXECUTE PROCEDURE tsvector_update_trigger(search_content, 'pg_catalog.english', name)
            '''
        ),
        migrations.RunSQL(
            sql='''
            CREATE OR REPLACE FUNCTION tsvector_update_trigger_on_process()
              RETURNS trigger AS
            $BODY$
            BEGIN
            SELECT to_tsvector(CONCAT(new.name) || ' ' || CONCAT(string_agg(pf.name, ' ')) || ' ' || CONCAT(string_agg(pt.value, ' ')) || ' ' || CONCAT(string_agg(pf2.value, ' ')))
            INTO new.search_content
            FROM processes_process pp
                   LEFT JOIN processes_kickoffvalue kv ON kv.process_id = pp.id AND pp.is_deleted is FALSE
                   LEFT JOIN processes_fileattachment pf ON pf.process_id = pp.id AND pf.is_deleted is FALSE
                   LEFT JOIN processes_taskfield pt on kv.id = pt.kickoff_id AND pt.is_deleted is FALSE
                   LEFT JOIN processes_fieldselection pf2
                     on pt.id = pf2.field_id AND pf2.is_selected is TRUE AND pf2.is_deleted is FALSE
            WHERE pp.id= new.id;
              RETURN new;
            END;
            $BODY$
              LANGUAGE plpgsql;
            ''',
            reverse_sql=migrations.RunSQL.noop
        ),
        migrations.RunSQL(
            sql='''
            CREATE TRIGGER process_ins BEFORE INSERT OR UPDATE ON processes_process FOR EACH ROW EXECUTE PROCEDURE tsvector_update_trigger_on_process();
            ''',
            reverse_sql='''
            DROP TRIGGER IF EXISTS process_ins ON processes_process;
            '''
        ),
        migrations.RunSQL(
            sql='''
            CREATE OR REPLACE FUNCTION tsvector_update_trigger_on_fileattachment()
              RETURNS trigger AS
            $BODY$
            BEGIN
              UPDATE processes_process
              SET name=name
              WHERE processes_process.id = new.process_id;
              RETURN new;
            end;
            $BODY$
              LANGUAGE plpgsql;
            ''',
            reverse_sql=migrations.RunSQL.noop
        ),
        migrations.RunSQL(
            sql='''
            CREATE TRIGGER fileattachments_ins AFTER INSERT OR UPDATE ON processes_fileattachment FOR EACH ROW EXECUTE PROCEDURE tsvector_update_trigger_on_fileattachment();
            ''',
            reverse_sql='''
            DROP TRIGGER IF EXISTS fileattachments_ins ON processes_fileattachment;
            '''
        ),
        migrations.RunSQL(
            sql='''
            DROP TRIGGER IF EXISTS tasks_ins ON processes_task;
            ''',
            reverse_sql='''
            CREATE TRIGGER tasks_ins BEFORE INSERT OR UPDATE ON processes_task FOR EACH ROW EXECUTE PROCEDURE tsvector_update_trigger(search_content, 'pg_catalog.english', name, description);
            '''
        ),
        migrations.RunSQL(
            sql='''
            CREATE OR REPLACE FUNCTION tsvector_update_trigger_on_task()
              RETURNS TRIGGER AS
            $BODY$
            BEGIN
              SELECT to_tsvector(CONCAT(new.name) || ' ' || CONCAT(new.description) || ' ' || CONCAT(string_agg(tf.value, ' ')) || ' ' || CONCAT(string_agg(fs.value, ' ')))
                  INTO new.search_content
              FROM processes_taskfield tf 
              LEFT JOIN processes_fieldselection fs ON (tf.id = fs.field_id AND fs.is_selected is TRUE AND fs.is_deleted is FALSE)
              WHERE tf.task_id=new.id AND tf.is_deleted is FALSE;
              RETURN new;
            END;
            $BODY$
            LANGUAGE plpgsql;
            ''',
            reverse_sql=migrations.RunSQL.noop
        ),
        migrations.RunSQL(
            sql='''
            CREATE TRIGGER tasks_ins BEFORE INSERT OR UPDATE ON processes_task FOR EACH ROW EXECUTE PROCEDURE tsvector_update_trigger_on_task();
            ''',
            reverse_sql='''
            DROP TRIGGER IF EXISTS tasks_ins ON processes_task;
            '''
        ),
        migrations.RunSQL(
            sql='''
            CREATE OR REPLACE FUNCTION tsvector_update_trigger_on_taskfield()
              RETURNS TRIGGER AS
            $BODY$
            BEGIN
              UPDATE processes_task SET name = name WHERE id = new.task_id;
              UPDATE processes_process p
              SET name = name
                     FROM processes_kickoffvalue k
              WHERE k.id = new.kickoff_id AND k.process_id=p.id;
              RETURN new;
            END;
            $BODY$
            LANGUAGE plpgsql;
            ''',
            reverse_sql=migrations.RunSQL.noop
        ),
        migrations.RunSQL(
            sql='''
            CREATE TRIGGER taskfield_ins AFTER INSERT OR UPDATE ON processes_taskfield FOR EACH ROW EXECUTE PROCEDURE tsvector_update_trigger_on_taskfield();
            ''',
            reverse_sql='''
            DROP TRIGGER IF EXISTS taskfield_ins ON processes_taskfield;
            '''
        ),
        migrations.RunPython(update_search_content, reverse_code=migrations.RunPython.noop)
    ]
